#!/bin/bash
#  ██████╗ ██╗   ██╗ ██████╗ ████████╗███████╗███████╗
# ██╔═══██╗██║   ██║██╔═══██╗╚══██╔══╝██╔════╝██╔════╝
# ██║   ██║██║   ██║██║   ██║   ██║   █████╗  ███████╗
# ██║▄▄ ██║██║   ██║██║   ██║   ██║   ██╔══╝  ╚════██║
# ╚██████╔╝╚██████╔╝╚██████╔╝   ██║   ███████╗███████║
#  ╚══▀▀═╝  ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚══════╝

QUOTES=(
  "100 functions on one structure beats ten"
  "640K should be enough for anybody"
  "Abstraction means being precise at new semantic levels"
  "Add indirection to solve computer science problems"
  "All programming is caching exercises"
  "Allocators should handle their resource deallocation"
  "Analyze information critically for your project context"
  "Analyze workflow to improve concurrency exploitation"
  "Automate bug detection after human discovery"
  "Avoid lion-tamer syndrome; focus on wins"
  "Be change catalyst; show future, help create it"
  "Berkeley produces LSD and UNIX coincidentally"
  "Broken software keeps you employed"
  "Caches are bugs waiting to happen"
  "Care about craft; develop software well"
  "Choose passion over boredom in life"
  "Code ain't done until tests run"
  "Code generators increase productivity and reduce duplication"
  "Code like your maintainer is a violent psychopath"
  "Communication matters as much as ideas"
  "Complexity kills developers and frustrates users"
  "Computer thinking like submarine swimming questions"
  "Computers only give answers, not questions"
  "Configure technology choices, don't integrate them"
  "Control complexity; it's programming's essence"
  "Coordinate workflow with blackboard pattern systems"
  "Curiosity drives intelligence and learning"
  "Dead programs damage less than crippled ones"
  "Debug calmly; breathe and think about causes"
  "Debug cleverly written code requires superior intelligence"
  "Design for concurrency to create cleaner interfaces"
  "Design services with concurrent, well-defined interfaces"
  "Design with contracts to verify code behavior"
  "Dig deep for buried requirements beneath assumptions"
  "Do things instead of describing them"
  "Don't blindly adopt techniques without development context"
  "Don't confuse yourself with own complexities"
  "Don't repeat yourself; maintain single knowledge sources"
  "Don't trust strange computers like R2D2"
  "Easy reuse encourages adoption and usage"
  "Easy things easy, hard things possible"
  "Education can't make expert programmers like paint"
  "Efficient useless work remains completely useless"
  "Eliminate effects between unrelated system components"
  "Estimate algorithm complexity before writing code"
  "Estimate early to spot potential problems"
  "Fail 90% means you're aiming high enough"
  "Fancy algorithms slow when n stays small"
  "Faulty RAM makes all loops infinite"
  "Find constraints when facing impossible problems"
  "Finishing distinguishes productivity from mere business"
  "First 90% takes 90%, remaining takes 90%"
  "Fix broken windows when you see them"
  "Fix problems, not blame assignments"
  "Fixed context progress usually means optimization"
  "Frozen specifications make development seem easy"
  "Geniuses remove complexity others merely suffer"
  "Gently exceed user expectations with understanding"
  "Good idioms only need learning once"
  "Good programmers check both ways on one-way streets"
  "Good software makes complex appear simple"
  "Great developers solve problems they're unqualified for"
  "High altitude computers need thicker air cushions"
  "Human memory inferior to compact disc storage"
  "Impossible things get done through ignorance"
  "Invest in abstractions, not implementations"
  "Iterate humanly; recurse divinely always"
  "Iterate schedules using implementation experience gained"
  "Judge tools on merit, not price tags"
  "Large projects get late one day"
  "Learn regularly; make knowledge investment habitual"
  "Learn text manipulation for daily work"
  "Lines of code measure weight, not progress"
  "Maintain project glossary for specific terms"
  "Make mistakes on hard problems only"
  "Make quality a user requirements issue"
  "Master single editor as hand extension"
  "Methods are functions with special arguments"
  "Minimize coupling with shy code practices"
  "Most patents are worthless time wasters"
  "No final decisions; plan for change"
  "Object-oriented programming structures spaghetti code better"
  "Old programs adapt machines to behave like themselves"
  "Only two industries call their customers \"users\""
  "Optimism hazards programming; feedback provides treatment"
  "Optimization hinders evolutionary development processes"
  "Organize teams around functionality, not roles"
  "Parallel programmers are bomb disposal experts"
  "Patterns mean language limitations reached"
  "Perfect software impossible; protect from errors"
  "Perfection means nothing left to remove"
  "Plain text knowledge won't become obsolete"
  "Planning hours save programming weeks"
  "Program close to problem domain language"
  "Programmer virtues: laziness, impatience, and hubris"
  "Programming languages get overrated by their practitioners"
  "Programming puts bugs in; debugging removes them"
  "Prototyping teaches lessons, not produces code"
  "Prove assumptions in actual environments with data"
  "Provide options instead of making excuses"
  "Put abstractions in code, details outside"
  "Reality must precede public relations for success"
  "Recursion trades description for computation time"
  "Refactor early and often like gardening"
  "Rely on reliable things, avoid coincidental programming"
  "Remember big picture while handling details"
  "Requirements shift; solve customer's changing problems"
  "Reserve exceptions for truly exceptional problems"
  "Scripts execute same instructions consistently"
  "Separate views from models for flexibility"
  "Sign your work with craftsman pride"
  "Simple designs show obvious deficiencies clearly"
  "Simplicity follows complexity, not precedes it"
  "Software development is inherently hard"
  "Software pyramids lack structural integrity, use force"
  "Solve problems first, then write code"
  "Source control is a time machine"
  "Specifications change easier than program rewrites"
  "Start when ready; experience builds constantly"
  "Start with specs; patches aren't architecture"
  "Structure data late in programming process"
  "Systems must be comprehensible to single individuals"
  "Telephone ease wish came true unfortunately"
  "Temporary solutions become permanent fixtures"
  "Test early, often, and automatically always"
  "Test estimates in target environments"
  "Test program states, not code coverage"
  "Test software ruthlessly before users do"
  "Test testing with purposeful bug injection"
  "Think about work; avoid autopilot programming"
  "Think like users by working together"
  "Think testing before writing any code lines"
  "Think twice before coding once"
  "Time for fixing but not rightes"
  "Tolerance for imperfection turns starters into finishers"
  "Tracer bullets help find targets accurately"
  "Turn back when traveling wrong roads"
  "Two programmers double time, not halve"
  "Understand wizard code before incorporating it"
  "Understanding means explaining to six-year-olds"
  "Understanding recursion requires understanding recursion first"
  "Unix allows stupid and clever things"
  "Unix is selectively friendly to chosen users"
  "Upward compatibility preserves all old mistakes"
  "Use assertions preventing impossible program states"
  "Use shells when GUIs don't work"
  "Users want working and fast software"
  "Write documents like code with DRY principles"
  "XML solves easy problems poorly"
)

NUM_QUOTES=${#QUOTES[@]}
RANDOM_INDEX=$((RANDOM % NUM_QUOTES))
echo " ${QUOTES[$RANDOM_INDEX]} " | lolcat -S 8
